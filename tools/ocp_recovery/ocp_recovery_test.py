#!/usr/bin/env python3

"""
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the MIT license.
"""

import sys
import re
import argparse
import subprocess
import secrets
import tempfile
import json
import time


def log_output (text, log_file = None):
    """
    Log test output.

    :param text:  Text data to log.
    :param log_file:  File output for the log.  If there is no file, the text will be printed to
        the screen.
    """

    if (log_file):
        with open (log_file, "a") as out:
            out.write (text)
    else:
        print (text, end = "")

def fail (msg = None, log_file = None):
    """
    Fail a test and abort the test script.

    :param msg:  A message to print to describe the failure.
    :param log_file:  File output for the log.  If there is no file, the text will be printed to
        the screen.
    """

    if (msg):
        log_output ("\n{0}\n".format (msg), log_file)

    log_output ("FAILURE!!!!!\n", log_file)
    sys.exit (1)

def check_result (result, log_file = None):
    """
    Check the result for a single application execution.  If the execution failed, this will
    terminate the test script.

    :param result:  Completion result object from the application execution.
    :param log_file:  File output for the results.  If there is no file, results will be printed to
        the screen.
    """

    log_output (result.stdout, log_file)

    if (result.returncode != 0):
        fail (log_file = log_file)

def get_ocp_options (args):
    """
    Construct the list of options for OCP application execution.

    :param args:  The user-defined arguments.

    :return A list containing the application parameters.  No command for the application will be
        added to the list.
    """
    ocp_args = [args.path, "-d", args.dev]

    if (args.addr):
        ocp_args.extend (["-a", args.addr])

    for i in range (args.verbose):
        ocp_args.append ("-v")

    return ocp_args

def run_cmd (args, cmd, timeout = 10):
    """
    Run a single OCP application command.

    :param args:  The user-defined arguments.
    :param cmd:  The list of command-specific application arguments.
    :param timeout:  Timeout to apply to command execution.

    :return Output generated by the command.
    """

    ocp_args = get_ocp_options (args)
    ocp_args.extend (cmd)

    log_output ("Cmd: {0}\n\n".format (" ".join (ocp_args)), args.log)

    result = subprocess.run (ocp_args, capture_output = True, timeout = timeout, text = True)
    check_result (result, log_file = args.log)

    return result.stdout

def run_cmd_sequence (args, cmd_list, timeout = 10):
    """
    Run a sequence of OCP application commands.

    :param args:  The user-defined arguments.
    :param cmd_list:  A list of commands to execute.  Each entry will be a list of command-specific
        application arguments.
    :param timeout:  Timeout to apply to each command being executed.  All commands use the same
        timeout value.
    """

    for cmd in cmd_list:
        run_cmd (args, cmd, timeout = timeout)

def check_ocp_status (args, expected = 0):
    """
    Check for protocol errors reported by the OCP target.  If the protocol status is not the
    expected value, the test script will exit.

    :param args:  The user-defined arguments.
    :param expected:  The expected protocol error states.
    """

    ocp_status = run_cmd (args, ["device_status"])

    proto_status = re.search ("Protocol Error: (0x..)", ocp_status)
    if (not proto_status):
        log_output ("Could not determine protocol status.\n", args.log)
        sys.exit (1)

    if (expected != int (proto_status.group (1), 16)):
        log_output ("Unexpected protocol status.  Expected {0}.\n".format (hex (expected)),
            args.log)
        sys.exit (1)

def get_cms_size (args, cms):
    """
    Determine the size of the specified CMS

    :param args:  The user-defined arguments.
    :param cms:  The CMS to check.

    :return The number of bytes in the CMS
    """

    run_cmd (args, ["-w", "indirect_ctrl", hex (cms), "0x00", "0x00"])
    indirect_status = run_cmd (args, ["indirect_status"])
    check_ocp_status (args)

    bytes = re.search ("Region Size:.* -> (0x.*) bytes", indirect_status)
    if (not bytes):
        log_output ("Could not determine region size.\n", args.log)
        sys.exit (1)

    return int (bytes.group (1), 16)

def fill_and_verify_cms (args, cms_info, timeout):
    """
    Write random data to an entire CMS.  Verify that the data was written correctly.

    :param args:  The user-defined arguments.
    :param cms_info:  Dictionary defining the CMS and parameters to use.
    :param timeout:  Timeout to apply to the commands.
    """

    cms = cms_info["cms"]
    load_args = ["-c", str (cms)]

    if ("write" in cms_info):
        load_args.extend (["-W", str (cms_info.get ("write"))])

    verify_args = load_args.copy ()

    with tempfile.NamedTemporaryFile (delete = True) as cms_file:
        cms_data = secrets.token_bytes (get_cms_size (args, cms))
        cms_file.write (cms_data)

        load_args.extend (["load_img", cms_file.name])
        verify_args.extend (["verify_img", cms_file.name])

        run_cmd_sequence (args, [load_args, verify_args], timeout = timeout)

def extract_byte_array (result, tag, length, check_len = None, check_offset = 0):
    """
    Extract a byte array from command results for verification against expected values.

    :param result:  The command result to search.
    :param tag:  Tag on the array to extract.
    :param length:  Total length of the array.
    :param check_len:  Length of the array that should be extracted.  The full array will be
        extracted if this is not set.
    :param check_offset:  Offset into the array to start extraction.  The array will start at offset
        0 if this is not set.  The offset is only applied when check_len is specified.

    :return A list containing the bytes for verification.
    """

    match_str = "{0} \({1}\):".format (tag, length)
    for i in range (length):
        match_str += "\s*(0x\S\S)"

    match = re.search (match_str, result)
    if (match):
        if (check_len):
            bytes = range (check_offset, check_offset + check_len)
        else:
            bytes = range (length)

        actual = []
        for i in bytes:
            actual.append (match.group (i + 1))

    return actual

def verify_expected_values (args, result, checklist):
    """
    Verify that the command results match the expected values.  If there is any mismatch, the test
    will exit.

    :param args:  The user-defined arguments.
    :param result:  Output from the executed command.
    :param checklist:  Dictionary of values to check in the output.
    """

    for check, expected in checklist.items ():
        actual = None

        # Handle checking for a integer value
        if (isinstance (expected, int)):
            match = re.search ("{0}:\s+(\d+)".format (check), result)
            if (match):
                actual = int (match.group (1))

        # Handle checking for a array of hex bytes
        elif (isinstance (expected, list)):
            actual = extract_byte_array (result, check, len (expected))

        # Handle checking for a sub-array of hex bytes
        elif (isinstance (expected, dict)):
            actual = extract_byte_array (result, check, expected.get ("length"),
                len (expected.get ("data")), expected.get ("offset", 0))

            expected = expected["data"]

        # Handle checking for the absence of a value
        elif (expected == None):
            actual = re.search (check, result)

        # Handle checking arbitrary string values
        else:
            match = re.search ("{0}:\s+(\S.*?)\\n".format (check), result)
            if (match):
                actual = match.group (1)

                value_decode = re.match ("(\S+) ->", actual)
                if (value_decode):
                    actual = value_decode.group (1)

        # Check the result and see if it matches the expectation
        if (expected == None):
            if (actual):
                fail ("Expected no value for {0}".format (check), args.log)
            else:
                log_output ("Check: {0} not present\n".format (check), args.log)
        else:
            if (actual == None):
                fail ("Cannot determine value for {0}".format (check), args.log)
            elif (actual != expected):
                fail ("Unexpected value for {0}: expected={1}, actual={2}".format (check, expected,
                    actual), args.log)
            else:
                log_output ("Check: {0} = {1}\n".format (check, expected), args.log)

    log_output ("\n", args.log)

def run_test_suite (args, suite_path):
    """
    Run a suite of user-defined tests.  The tests are sets of commands defined in JSON.

    :param args:  The user-defined arguments.
    :param suite_path:  Path to the JSON file that defines the test suite to execute.
    """

    with open (suite_path, "r") as input_file:
        suite = json.load (input_file)

    for test in suite.get ("suite"):
        iterations = test.get ("loop", 1)

        for i in range (iterations):
            log_output ("-------------------------------------\n", args.log)
            log_output ("--  TEST CASE: {0}\n".format (test.get ("test")), args.log)
            if (iterations > 1):
                log_output ("--  ITERATION: {0}\n".format (i + 1), args.log)
            log_output ("-------------------------------------\n", args.log)
            log_output ("\n", args.log)

            for step in test.get ("steps"):
                cmd_timeout = step.get ("timeout", 10)

                if ("commands" in step):
                    for cmd, validation in step.get ("commands").items ():
                        result = run_cmd (args, cmd.split (), timeout = cmd_timeout)
                        verify_expected_values (args, result, validation)
                elif ("fill_cms" in step):
                    fill_and_verify_cms (args, step.get ("fill_cms"), cmd_timeout)
                else:
                    fail ("Invalid test step", args.log)

                if ("delay" in step):
                    time.sleep (step.get ("delay"))


if __name__ == '__main__':
    parser = argparse.ArgumentParser (description = "Tester for OCP recovery interface")

    parser.add_argument ("--path", action = "store", default = "./ocp_recovery",
        help = "Path to the testing application (default: ./ocp_recovery)")
    parser.add_argument ("--dev", action = "store", default = "1",
        help = "I2C device number connected to the OCP recovery interface (default: 1)")
    parser.add_argument ("--addr", action = "store",
        help = "I2C address of the OCP device (default: 0x69)")
    parser.add_argument ("--verbose", action = "store", type = int, default = 0,
        help = "Set verbosity of test application output")

    parser.add_argument ("--log", action = "store",
        help = "Path to a log file that should be appended with the test output")
    parser.add_argument ("suite", nargs='+',
        help = "Execute a suite of tests defined in a JSON file against the device")

    args = parser.parse_args ()

    # Create an empty log file
    if (args.log):
        open (args.log, "a").close ()

    for suite in args.suite:
        log_output ("-------------------------------------\n", args.log)
        log_output ("--  TEST SUITE: {0}\n".format (suite), args.log)
        log_output ("-------------------------------------\n", args.log)
        log_output ("\n", args.log)

        run_test_suite (args, suite)

        log_output ("\n", args.log)
        log_output ("+++++++++++++++++++++++++++++++++++++\n", args.log)
        log_output ("\n", args.log)
